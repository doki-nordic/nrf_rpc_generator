const { createHash } = require('crypto');


/** @module CodeBlocks */


const HEADER = exports.HEADER = 'header';
const BEGIN = exports.BEGIN = 'begin';
const LOCALS = exports.LOCALS = 'locals';
const CALC = exports.CALC = 'calculate';
const ALLOCATE = exports.ALLOCATE = 'allocate';
const ENCODE = exports.ENCODE = 'encode';
const DECODE = exports.DECODE = 'decode';
const SEND = exports.SEND = 'send';
const RETURN = exports.RETURN = 'return';
const FOOTER = exports.FOOTER = 'footer';
const FIELDS = exports.FIELDS = 'fields';
const ENCODE_RES = exports.ENCODE_RES = 'encode_res';
const DECODE_RES = exports.DECODE_RES = 'decode_res';
const ASSIGN = exports.ASSIGN = 'assign';
const DECODE_DONE = exports.DECODE_DONE = 'decode_done';
const INVALID = exports.INVALID = 'invalid';
const EXECUTE = exports.EXECUTE = 'execute';
const BUFFER_MAX = exports.BUFFER_MAX = 'buffer_max';
const SCRATCHPAD_CALC = exports.SCRATCHPAD_CALC = 'scratchpad_calc';
const SCRATCHPAD_ALLOC = exports.SCRATCHPAD_ALLOC = 'scratchpad_alloc';
const SCRATCHPAD_FREE = exports.SCRATCHPAD_FREE = 'scratchpad_free';
const OUTPUT_ALLOC = exports.OUTPUT_ALLOC = 'output_alloc';
const ANNOTATION = exports.ANNOTATION = 'annotation';

const numberToName = {
	[0]: BEGIN,
	[1]: LOCALS,
	[2]: ALLOCATE,
	[3]: ENCODE,
	[4]: SEND,
	[5]: RETURN,
	[6]: HEADER,
	[7]: FOOTER,
	[8]: CALC,
	[9]: FIELDS,
	[10]: DECODE,
	[11]: ASSIGN,
	[12]: ENCODE_RES,
	[13]: DECODE_RES,
	[20]: DECODE_DONE,
	[14]: EXECUTE,
	[15]: OUTPUT_ALLOC,
	[16]: SCRATCHPAD_CALC,
	[17]: SCRATCHPAD_ALLOC,
	[18]: SCRATCHPAD_FREE,
	[19]: ANNOTATION,
	[255]: INVALID,
	[255]: BUFFER_MAX, // Internal code block, not generated
};

const nameToNumber = {};
for (let x in numberToName){
	nameToNumber[numberToName[x]] = x;
}


function codeChecksum(code) {
	code = code
		.replace(/\/\*.*?\*\/|\/\/.*?(?=\n)/g, ' ')
		.replace(/[\x00- ]+/g, ' ')
		.replace(/(?<=[^a-z0-9_\$]) /gi, '')
		.replace(/ (?=[^a-z0-9_\$])/gi, '')
		.trim();
	const hash = createHash('sha256');
	hash.update(code);
	let buf = hash.digest('buffer');
	return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
}


function parseSideData(sideData) {
	let buf = Buffer.from(sideData, 'base64');
	return {
		type: numberToName[buf[0]],
		crc: buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24)
	};
}


function createSideData(type, crc) {
	let buf = Buffer.from([
		nameToNumber[type],
		crc & 0xFF,
		(crc >> 8) & 0xFF,
		(crc >> 16) & 0xFF,
		(crc >> 24) & 0xFF
	]);
	return buf.toString('base64').substr(0, 7);
}


function validate(code, sideData) {
	let crc = codeChecksum(code);
	let info = parseSideData(sideData);
	if (info.crc != crc || info.type === undefined) {
		throw Error(`Side data of autogenerated code is invalid. Expected '${createSideData(info.type || INVALID, crc)}', Current '${sideData}'`);
	}
	return info.type;
}


exports.numberToName = numberToName;
exports.nameToNumber = nameToNumber;
exports.codeChecksum = codeChecksum;
exports.parseSideData = parseSideData;
exports.createSideData = createSideData;
exports.validate = validate;
